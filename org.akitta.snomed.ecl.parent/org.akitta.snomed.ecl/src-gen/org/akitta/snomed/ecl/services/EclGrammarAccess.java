/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package org.akitta.snomed.ecl.services;

import java.util.List;

import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

import com.google.inject.Inject;
import com.google.inject.Singleton;

@Singleton
public class EclGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ScriptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.Script");
		private final Assignment cConstraintAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cConstraintExpressionConstraintParserRuleCall_0 = (RuleCall)cConstraintAssignment.eContents().get(0);
		
		//Script:
		//	constraint=ExpressionConstraint?;
		@Override public ParserRule getRule() { return rule; }
		
		//constraint=ExpressionConstraint?
		public Assignment getConstraintAssignment() { return cConstraintAssignment; }
		
		//ExpressionConstraint
		public RuleCall getConstraintExpressionConstraintParserRuleCall_0() { return cConstraintExpressionConstraintParserRuleCall_0; }
	}
	public class ExpressionConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ExpressionConstraint");
		private final RuleCall cExclusionExpressionConstraintParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ExpressionConstraint:
		//	ExclusionExpressionConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		//ExclusionExpressionConstraint
		public RuleCall getExclusionExpressionConstraintParserRuleCall() { return cExclusionExpressionConstraintParserRuleCall; }
	}
	public class ExclusionExpressionConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ExclusionExpressionConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDisjunctionExpressionConstraintParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cExclusionExpressionConstraintLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpExclusionOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightDisjunctionExpressionConstraintParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//ExclusionExpressionConstraint ExpressionConstraint:
		//	DisjunctionExpressionConstraint (=> ({ExclusionExpressionConstraint.left=current} op=ExclusionOperator)
		//	right=DisjunctionExpressionConstraint)*
		@Override public ParserRule getRule() { return rule; }
		
		//DisjunctionExpressionConstraint (=> ({ExclusionExpressionConstraint.left=current} op=ExclusionOperator)
		//right=DisjunctionExpressionConstraint)*
		public Group getGroup() { return cGroup; }
		
		//DisjunctionExpressionConstraint
		public RuleCall getDisjunctionExpressionConstraintParserRuleCall_0() { return cDisjunctionExpressionConstraintParserRuleCall_0; }
		
		//(=> ({ExclusionExpressionConstraint.left=current} op=ExclusionOperator) right=DisjunctionExpressionConstraint)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ExclusionExpressionConstraint.left=current} op=ExclusionOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({ExclusionExpressionConstraint.left=current} op=ExclusionOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ExclusionExpressionConstraint.left=current}
		public Action getExclusionExpressionConstraintLeftAction_1_0_0_0() { return cExclusionExpressionConstraintLeftAction_1_0_0_0; }
		
		//op=ExclusionOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//ExclusionOperator
		public RuleCall getOpExclusionOperatorEnumRuleCall_1_0_0_1_0() { return cOpExclusionOperatorEnumRuleCall_1_0_0_1_0; }
		
		//right=DisjunctionExpressionConstraint
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//DisjunctionExpressionConstraint
		public RuleCall getRightDisjunctionExpressionConstraintParserRuleCall_1_1_0() { return cRightDisjunctionExpressionConstraintParserRuleCall_1_1_0; }
	}
	public class DisjunctionExpressionConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.DisjunctionExpressionConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctionExpressionConstraintParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cDisjunctionExpressionConstraintLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightConjunctionExpressionConstraintParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//DisjunctionExpressionConstraint ExpressionConstraint:
		//	ConjunctionExpressionConstraint (=> ({DisjunctionExpressionConstraint.left=current} op=DisjunctionOperator)
		//	right=ConjunctionExpressionConstraint)*
		@Override public ParserRule getRule() { return rule; }
		
		//ConjunctionExpressionConstraint (=> ({DisjunctionExpressionConstraint.left=current} op=DisjunctionOperator)
		//right=ConjunctionExpressionConstraint)*
		public Group getGroup() { return cGroup; }
		
		//ConjunctionExpressionConstraint
		public RuleCall getConjunctionExpressionConstraintParserRuleCall_0() { return cConjunctionExpressionConstraintParserRuleCall_0; }
		
		//(=> ({DisjunctionExpressionConstraint.left=current} op=DisjunctionOperator) right=ConjunctionExpressionConstraint)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({DisjunctionExpressionConstraint.left=current} op=DisjunctionOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({DisjunctionExpressionConstraint.left=current} op=DisjunctionOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{DisjunctionExpressionConstraint.left=current}
		public Action getDisjunctionExpressionConstraintLeftAction_1_0_0_0() { return cDisjunctionExpressionConstraintLeftAction_1_0_0_0; }
		
		//op=DisjunctionOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//DisjunctionOperator
		public RuleCall getOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0() { return cOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0; }
		
		//right=ConjunctionExpressionConstraint
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//ConjunctionExpressionConstraint
		public RuleCall getRightConjunctionExpressionConstraintParserRuleCall_1_1_0() { return cRightConjunctionExpressionConstraintParserRuleCall_1_1_0; }
	}
	public class ConjunctionExpressionConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ConjunctionExpressionConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRefinedExpressionConstraintParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cConjunctionExpressionConstraintLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpConjunctionOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightRefinedExpressionConstraintParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//ConjunctionExpressionConstraint ExpressionConstraint:
		//	RefinedExpressionConstraint (=> ({ConjunctionExpressionConstraint.left=current} op=ConjunctionOperator)
		//	right=RefinedExpressionConstraint)*
		@Override public ParserRule getRule() { return rule; }
		
		//RefinedExpressionConstraint (=> ({ConjunctionExpressionConstraint.left=current} op=ConjunctionOperator)
		//right=RefinedExpressionConstraint)*
		public Group getGroup() { return cGroup; }
		
		//RefinedExpressionConstraint
		public RuleCall getRefinedExpressionConstraintParserRuleCall_0() { return cRefinedExpressionConstraintParserRuleCall_0; }
		
		//(=> ({ConjunctionExpressionConstraint.left=current} op=ConjunctionOperator) right=RefinedExpressionConstraint)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ConjunctionExpressionConstraint.left=current} op=ConjunctionOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({ConjunctionExpressionConstraint.left=current} op=ConjunctionOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ConjunctionExpressionConstraint.left=current}
		public Action getConjunctionExpressionConstraintLeftAction_1_0_0_0() { return cConjunctionExpressionConstraintLeftAction_1_0_0_0; }
		
		//op=ConjunctionOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//ConjunctionOperator
		public RuleCall getOpConjunctionOperatorEnumRuleCall_1_0_0_1_0() { return cOpConjunctionOperatorEnumRuleCall_1_0_0_1_0; }
		
		//right=RefinedExpressionConstraint
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//RefinedExpressionConstraint
		public RuleCall getRightRefinedExpressionConstraintParserRuleCall_1_1_0() { return cRightRefinedExpressionConstraintParserRuleCall_1_1_0; }
	}
	public class RefinedExpressionConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.RefinedExpressionConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionConstraintParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRefinedExpressionConstraintTargetAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRefinementAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRefinementRefinementParserRuleCall_1_2_0 = (RuleCall)cRefinementAssignment_1_2.eContents().get(0);
		
		//RefinedExpressionConstraint ExpressionConstraint:
		//	PrimaryExpressionConstraint ({RefinedExpressionConstraint.target=current} ':' refinement=Refinement)?
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpressionConstraint ({RefinedExpressionConstraint.target=current} ':' refinement=Refinement)?
		public Group getGroup() { return cGroup; }
		
		//PrimaryExpressionConstraint
		public RuleCall getPrimaryExpressionConstraintParserRuleCall_0() { return cPrimaryExpressionConstraintParserRuleCall_0; }
		
		//({RefinedExpressionConstraint.target=current} ':' refinement=Refinement)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{RefinedExpressionConstraint.target=current}
		public Action getRefinedExpressionConstraintTargetAction_1_0() { return cRefinedExpressionConstraintTargetAction_1_0; }
		
		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }
		
		//refinement=Refinement
		public Assignment getRefinementAssignment_1_2() { return cRefinementAssignment_1_2; }
		
		//Refinement
		public RuleCall getRefinementRefinementParserRuleCall_1_2_0() { return cRefinementRefinementParserRuleCall_1_2_0; }
	}
	public class RefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.Refinement");
		private final RuleCall cDisjunctionRefinementSetParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Refinement:
		//	DisjunctionRefinementSet;
		@Override public ParserRule getRule() { return rule; }
		
		//DisjunctionRefinementSet
		public RuleCall getDisjunctionRefinementSetParserRuleCall() { return cDisjunctionRefinementSetParserRuleCall; }
	}
	public class DisjunctionRefinementSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.DisjunctionRefinementSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctionRefinementSetParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cDisjunctionRefinementSetLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightConjunctionRefinementSetParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//DisjunctionRefinementSet Refinement:
		//	ConjunctionRefinementSet (=> ({DisjunctionRefinementSet.left=current} op=DisjunctionOperator)
		//	right=ConjunctionRefinementSet)*
		@Override public ParserRule getRule() { return rule; }
		
		//ConjunctionRefinementSet (=> ({DisjunctionRefinementSet.left=current} op=DisjunctionOperator)
		//right=ConjunctionRefinementSet)*
		public Group getGroup() { return cGroup; }
		
		//ConjunctionRefinementSet
		public RuleCall getConjunctionRefinementSetParserRuleCall_0() { return cConjunctionRefinementSetParserRuleCall_0; }
		
		//(=> ({DisjunctionRefinementSet.left=current} op=DisjunctionOperator) right=ConjunctionRefinementSet)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({DisjunctionRefinementSet.left=current} op=DisjunctionOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({DisjunctionRefinementSet.left=current} op=DisjunctionOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{DisjunctionRefinementSet.left=current}
		public Action getDisjunctionRefinementSetLeftAction_1_0_0_0() { return cDisjunctionRefinementSetLeftAction_1_0_0_0; }
		
		//op=DisjunctionOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//DisjunctionOperator
		public RuleCall getOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0() { return cOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0; }
		
		//right=ConjunctionRefinementSet
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//ConjunctionRefinementSet
		public RuleCall getRightConjunctionRefinementSetParserRuleCall_1_1_0() { return cRightConjunctionRefinementSetParserRuleCall_1_1_0; }
	}
	public class ConjunctionRefinementSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ConjunctionRefinementSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSubRefinementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cConjunctionRefinementSetLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpConjunctionOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSubRefinementParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//ConjunctionRefinementSet Refinement:
		//	SubRefinement (=> ({ConjunctionRefinementSet.left=current} op=ConjunctionOperator) right=SubRefinement)*
		@Override public ParserRule getRule() { return rule; }
		
		//SubRefinement (=> ({ConjunctionRefinementSet.left=current} op=ConjunctionOperator) right=SubRefinement)*
		public Group getGroup() { return cGroup; }
		
		//SubRefinement
		public RuleCall getSubRefinementParserRuleCall_0() { return cSubRefinementParserRuleCall_0; }
		
		//(=> ({ConjunctionRefinementSet.left=current} op=ConjunctionOperator) right=SubRefinement)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ConjunctionRefinementSet.left=current} op=ConjunctionOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({ConjunctionRefinementSet.left=current} op=ConjunctionOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ConjunctionRefinementSet.left=current}
		public Action getConjunctionRefinementSetLeftAction_1_0_0_0() { return cConjunctionRefinementSetLeftAction_1_0_0_0; }
		
		//op=ConjunctionOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//ConjunctionOperator
		public RuleCall getOpConjunctionOperatorEnumRuleCall_1_0_0_1_0() { return cOpConjunctionOperatorEnumRuleCall_1_0_0_1_0; }
		
		//right=SubRefinement
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//SubRefinement
		public RuleCall getRightSubRefinementParserRuleCall_1_1_0() { return cRightSubRefinementParserRuleCall_1_1_0; }
	}
	public class SubRefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.SubRefinement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAttributeSetRefinementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeGroupRefinementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cParenthesizedRefinementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//SubRefinement Refinement:
		//	AttributeSetRefinement
		//	| AttributeGroupRefinement
		//	| ParenthesizedRefinement
		@Override public ParserRule getRule() { return rule; }
		
		//AttributeSetRefinement | AttributeGroupRefinement | ParenthesizedRefinement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AttributeSetRefinement
		public RuleCall getAttributeSetRefinementParserRuleCall_0() { return cAttributeSetRefinementParserRuleCall_0; }
		
		//AttributeGroupRefinement
		public RuleCall getAttributeGroupRefinementParserRuleCall_1() { return cAttributeGroupRefinementParserRuleCall_1; }
		
		//ParenthesizedRefinement
		public RuleCall getParenthesizedRefinementParserRuleCall_2() { return cParenthesizedRefinementParserRuleCall_2; }
	}
	public class AttributeSetRefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.AttributeSetRefinement");
		private final Assignment cAttributeSetAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cAttributeSetDisjunctionAttributeSetParserRuleCall_0 = (RuleCall)cAttributeSetAssignment.eContents().get(0);
		
		//AttributeSetRefinement:
		//	attributeSet=DisjunctionAttributeSet;
		@Override public ParserRule getRule() { return rule; }
		
		//attributeSet=DisjunctionAttributeSet
		public Assignment getAttributeSetAssignment() { return cAttributeSetAssignment; }
		
		//DisjunctionAttributeSet
		public RuleCall getAttributeSetDisjunctionAttributeSetParserRuleCall_0() { return cAttributeSetDisjunctionAttributeSetParserRuleCall_0; }
	}
	public class AttributeGroupRefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.AttributeGroupRefinement");
		private final Assignment cAttributeGroupAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cAttributeGroupAttributeGroupParserRuleCall_0 = (RuleCall)cAttributeGroupAssignment.eContents().get(0);
		
		//AttributeGroupRefinement:
		//	attributeGroup=AttributeGroup;
		@Override public ParserRule getRule() { return rule; }
		
		//attributeGroup=AttributeGroup
		public Assignment getAttributeGroupAssignment() { return cAttributeGroupAssignment; }
		
		//AttributeGroup
		public RuleCall getAttributeGroupAttributeGroupParserRuleCall_0() { return cAttributeGroupAttributeGroupParserRuleCall_0; }
	}
	public class DisjunctionAttributeSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.DisjunctionAttributeSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctionAttributeSetParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cDisjunctionAttributeSetLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightConjunctionAttributeSetParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//DisjunctionAttributeSet AttributeSet:
		//	ConjunctionAttributeSet (=> ({DisjunctionAttributeSet.left=current} op=DisjunctionOperator)
		//	right=ConjunctionAttributeSet)*
		@Override public ParserRule getRule() { return rule; }
		
		//ConjunctionAttributeSet (=> ({DisjunctionAttributeSet.left=current} op=DisjunctionOperator)
		//right=ConjunctionAttributeSet)*
		public Group getGroup() { return cGroup; }
		
		//ConjunctionAttributeSet
		public RuleCall getConjunctionAttributeSetParserRuleCall_0() { return cConjunctionAttributeSetParserRuleCall_0; }
		
		//(=> ({DisjunctionAttributeSet.left=current} op=DisjunctionOperator) right=ConjunctionAttributeSet)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({DisjunctionAttributeSet.left=current} op=DisjunctionOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({DisjunctionAttributeSet.left=current} op=DisjunctionOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{DisjunctionAttributeSet.left=current}
		public Action getDisjunctionAttributeSetLeftAction_1_0_0_0() { return cDisjunctionAttributeSetLeftAction_1_0_0_0; }
		
		//op=DisjunctionOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//DisjunctionOperator
		public RuleCall getOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0() { return cOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0; }
		
		//right=ConjunctionAttributeSet
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//ConjunctionAttributeSet
		public RuleCall getRightConjunctionAttributeSetParserRuleCall_1_1_0() { return cRightConjunctionAttributeSetParserRuleCall_1_1_0; }
	}
	public class ConjunctionAttributeSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ConjunctionAttributeSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryAttributeSetParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cConjunctionAttributeSetLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpConjunctionOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPrimaryAttributeSetParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//ConjunctionAttributeSet AttributeSet:
		//	PrimaryAttributeSet (=> ({ConjunctionAttributeSet.left=current} op=ConjunctionOperator) right=PrimaryAttributeSet)*
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryAttributeSet (=> ({ConjunctionAttributeSet.left=current} op=ConjunctionOperator) right=PrimaryAttributeSet)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryAttributeSet
		public RuleCall getPrimaryAttributeSetParserRuleCall_0() { return cPrimaryAttributeSetParserRuleCall_0; }
		
		//(=> ({ConjunctionAttributeSet.left=current} op=ConjunctionOperator) right=PrimaryAttributeSet)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ConjunctionAttributeSet.left=current} op=ConjunctionOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({ConjunctionAttributeSet.left=current} op=ConjunctionOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ConjunctionAttributeSet.left=current}
		public Action getConjunctionAttributeSetLeftAction_1_0_0_0() { return cConjunctionAttributeSetLeftAction_1_0_0_0; }
		
		//op=ConjunctionOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//ConjunctionOperator
		public RuleCall getOpConjunctionOperatorEnumRuleCall_1_0_0_1_0() { return cOpConjunctionOperatorEnumRuleCall_1_0_0_1_0; }
		
		//right=PrimaryAttributeSet
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//PrimaryAttributeSet
		public RuleCall getRightPrimaryAttributeSetParserRuleCall_1_1_0() { return cRightPrimaryAttributeSetParserRuleCall_1_1_0; }
	}
	public class PrimaryAttributeSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.PrimaryAttributeSet");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParenthesizedAttributeSetParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PrimaryAttributeSet AttributeSet:
		//	ParenthesizedAttributeSet | Attribute
		@Override public ParserRule getRule() { return rule; }
		
		//ParenthesizedAttributeSet | Attribute
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ParenthesizedAttributeSet
		public RuleCall getParenthesizedAttributeSetParserRuleCall_0() { return cParenthesizedAttributeSetParserRuleCall_0; }
		
		//Attribute
		public RuleCall getAttributeParserRuleCall_1() { return cAttributeParserRuleCall_1; }
	}
	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.Attribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCardinalityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCardinalityCardinalityParserRuleCall_0_0 = (RuleCall)cCardinalityAssignment_0.eContents().get(0);
		private final Assignment cReversedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReversedREVERSETerminalRuleCall_1_0 = (RuleCall)cReversedAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOpAttributeOperatorEnumRuleCall_2_0 = (RuleCall)cOpAssignment_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cConceptRefAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cConceptRefConceptReferenceParserRuleCall_3_0_0 = (RuleCall)cConceptRefAssignment_3_0.eContents().get(0);
		private final Assignment cWildcardAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final Keyword cWildcardAsteriskKeyword_3_1_0 = (Keyword)cWildcardAssignment_3_1.eContents().get(0);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueAttributeValueParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		
		//Attribute:
		//	cardinality=Cardinality?
		//	reversed?=REVERSE?
		//	op=AttributeOperator? (conceptRef=ConceptReference | wildcard?='*') value=AttributeValue;
		@Override public ParserRule getRule() { return rule; }
		
		//cardinality=Cardinality? reversed?=REVERSE? op=AttributeOperator? (conceptRef=ConceptReference | wildcard?='*')
		//value=AttributeValue
		public Group getGroup() { return cGroup; }
		
		//cardinality=Cardinality?
		public Assignment getCardinalityAssignment_0() { return cCardinalityAssignment_0; }
		
		//Cardinality
		public RuleCall getCardinalityCardinalityParserRuleCall_0_0() { return cCardinalityCardinalityParserRuleCall_0_0; }
		
		//reversed?=REVERSE?
		public Assignment getReversedAssignment_1() { return cReversedAssignment_1; }
		
		//REVERSE
		public RuleCall getReversedREVERSETerminalRuleCall_1_0() { return cReversedREVERSETerminalRuleCall_1_0; }
		
		//op=AttributeOperator?
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//AttributeOperator
		public RuleCall getOpAttributeOperatorEnumRuleCall_2_0() { return cOpAttributeOperatorEnumRuleCall_2_0; }
		
		//(conceptRef=ConceptReference | wildcard?='*')
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//conceptRef=ConceptReference
		public Assignment getConceptRefAssignment_3_0() { return cConceptRefAssignment_3_0; }
		
		//ConceptReference
		public RuleCall getConceptRefConceptReferenceParserRuleCall_3_0_0() { return cConceptRefConceptReferenceParserRuleCall_3_0_0; }
		
		//wildcard?='*'
		public Assignment getWildcardAssignment_3_1() { return cWildcardAssignment_3_1; }
		
		//'*'
		public Keyword getWildcardAsteriskKeyword_3_1_0() { return cWildcardAsteriskKeyword_3_1_0; }
		
		//value=AttributeValue
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }
		
		//AttributeValue
		public RuleCall getValueAttributeValueParserRuleCall_4_0() { return cValueAttributeValueParserRuleCall_4_0; }
	}
	public class CardinalityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.Cardinality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFromAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFromINTTerminalRuleCall_1_0 = (RuleCall)cFromAssignment_1.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cToAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cToINTTerminalRuleCall_3_0_0 = (RuleCall)cToAssignment_3_0.eContents().get(0);
		private final Assignment cManyAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final Keyword cManyAsteriskKeyword_3_1_0 = (Keyword)cManyAssignment_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Cardinality:
		//	'[' from=INT '..' (to=INT | many?='*') ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' from=INT '..' (to=INT | many?='*') ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//from=INT
		public Assignment getFromAssignment_1() { return cFromAssignment_1; }
		
		//INT
		public RuleCall getFromINTTerminalRuleCall_1_0() { return cFromINTTerminalRuleCall_1_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_2() { return cFullStopFullStopKeyword_2; }
		
		//(to=INT | many?='*')
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//to=INT
		public Assignment getToAssignment_3_0() { return cToAssignment_3_0; }
		
		//INT
		public RuleCall getToINTTerminalRuleCall_3_0_0() { return cToINTTerminalRuleCall_3_0_0; }
		
		//many?='*'
		public Assignment getManyAssignment_3_1() { return cManyAssignment_3_1; }
		
		//'*'
		public Keyword getManyAsteriskKeyword_3_1_0() { return cManyAsteriskKeyword_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class AttributeValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.AttributeValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumericValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStringValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//AttributeValue:
		//	ExpressionValue | NumericValue | StringValue;
		@Override public ParserRule getRule() { return rule; }
		
		//ExpressionValue | NumericValue | StringValue
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExpressionValue
		public RuleCall getExpressionValueParserRuleCall_0() { return cExpressionValueParserRuleCall_0; }
		
		//NumericValue
		public RuleCall getNumericValueParserRuleCall_1() { return cNumericValueParserRuleCall_1; }
		
		//StringValue
		public RuleCall getStringValueParserRuleCall_2() { return cStringValueParserRuleCall_2; }
	}
	public class StringValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.StringValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpStringComparisonOperatorEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//StringValue:
		//	op=StringComparisonOperator value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//op=StringComparisonOperator value=STRING
		public Group getGroup() { return cGroup; }
		
		//op=StringComparisonOperator
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//StringComparisonOperator
		public RuleCall getOpStringComparisonOperatorEnumRuleCall_0_0() { return cOpStringComparisonOperatorEnumRuleCall_0_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}
	public class NumericValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.NumericValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpNumericComparisonOperatorEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueNumberParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//NumericValue:
		//	op=NumericComparisonOperator '#' value=Number;
		@Override public ParserRule getRule() { return rule; }
		
		//op=NumericComparisonOperator '#' value=Number
		public Group getGroup() { return cGroup; }
		
		//op=NumericComparisonOperator
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//NumericComparisonOperator
		public RuleCall getOpNumericComparisonOperatorEnumRuleCall_0_0() { return cOpNumericComparisonOperatorEnumRuleCall_0_0; }
		
		//'#'
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }
		
		//value=Number
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Number
		public RuleCall getValueNumberParserRuleCall_2_0() { return cValueNumberParserRuleCall_2_0; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.Number");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//Number ecore::EBigDecimal:
		//	INT ('.' INT)?
		@Override public ParserRule getRule() { return rule; }
		
		//INT ('.' INT)?
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//('.' INT)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}
	public class ExpressionValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ExpressionValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpExpressionComparisonOperatorEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuePrimaryExpressionConstraintParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//ExpressionValue:
		//	op=ExpressionComparisonOperator value=PrimaryExpressionConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		//op=ExpressionComparisonOperator value=PrimaryExpressionConstraint
		public Group getGroup() { return cGroup; }
		
		//op=ExpressionComparisonOperator
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//ExpressionComparisonOperator
		public RuleCall getOpExpressionComparisonOperatorEnumRuleCall_0_0() { return cOpExpressionComparisonOperatorEnumRuleCall_0_0; }
		
		//value=PrimaryExpressionConstraint
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//PrimaryExpressionConstraint
		public RuleCall getValuePrimaryExpressionConstraintParserRuleCall_1_0() { return cValuePrimaryExpressionConstraintParserRuleCall_1_0; }
	}
	public class ParenthesizedAttributeSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ParenthesizedAttributeSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cDisjunctionAttributeSetParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesizedAttributeSet AttributeSet:
		//	'(' DisjunctionAttributeSet ')'
		@Override public ParserRule getRule() { return rule; }
		
		//'(' DisjunctionAttributeSet ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//DisjunctionAttributeSet
		public RuleCall getDisjunctionAttributeSetParserRuleCall_1() { return cDisjunctionAttributeSetParserRuleCall_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class AttributeGroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.AttributeGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCardinalityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCardinalityCardinalityParserRuleCall_0_0 = (RuleCall)cCardinalityAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeSetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributeSetDisjunctionAttributeSetParserRuleCall_2_0 = (RuleCall)cAttributeSetAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//AttributeGroup:
		//	cardinality=Cardinality? '{' attributeSet=DisjunctionAttributeSet '}';
		@Override public ParserRule getRule() { return rule; }
		
		//cardinality=Cardinality? '{' attributeSet=DisjunctionAttributeSet '}'
		public Group getGroup() { return cGroup; }
		
		//cardinality=Cardinality?
		public Assignment getCardinalityAssignment_0() { return cCardinalityAssignment_0; }
		
		//Cardinality
		public RuleCall getCardinalityCardinalityParserRuleCall_0_0() { return cCardinalityCardinalityParserRuleCall_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//attributeSet=DisjunctionAttributeSet
		public Assignment getAttributeSetAssignment_2() { return cAttributeSetAssignment_2; }
		
		//DisjunctionAttributeSet
		public RuleCall getAttributeSetDisjunctionAttributeSetParserRuleCall_2_0() { return cAttributeSetDisjunctionAttributeSetParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class ParenthesizedRefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ParenthesizedRefinement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cRefinementParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesizedRefinement Refinement:
		//	'(' Refinement ')'
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Refinement ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//Refinement
		public RuleCall getRefinementParserRuleCall_1() { return cRefinementParserRuleCall_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class PrimaryExpressionConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.PrimaryExpressionConstraint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSimpleExpressionConstraintParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionConstraintParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Action cParenthesizedExpressionConstraintCurrentAction_1_2 = (Action)cGroup_1.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//PrimaryExpressionConstraint ExpressionConstraint:
		//	SimpleExpressionConstraint |
		//	'(' ExpressionConstraint {ParenthesizedExpressionConstraint.^current=current} ')'
		@Override public ParserRule getRule() { return rule; }
		
		//SimpleExpressionConstraint | '(' ExpressionConstraint {ParenthesizedExpressionConstraint.^current=current} ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SimpleExpressionConstraint
		public RuleCall getSimpleExpressionConstraintParserRuleCall_0() { return cSimpleExpressionConstraintParserRuleCall_0; }
		
		//'(' ExpressionConstraint {ParenthesizedExpressionConstraint.^current=current} ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//ExpressionConstraint
		public RuleCall getExpressionConstraintParserRuleCall_1_1() { return cExpressionConstraintParserRuleCall_1_1; }
		
		//{ParenthesizedExpressionConstraint.^current=current}
		public Action getParenthesizedExpressionConstraintCurrentAction_1_2() { return cParenthesizedExpressionConstraintCurrentAction_1_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class SimpleExpressionConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.SimpleExpressionConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpConstraintOperatorEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cConceptAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConceptFocusConceptParserRuleCall_1_0 = (RuleCall)cConceptAssignment_1.eContents().get(0);
		
		//SimpleExpressionConstraint:
		//	op=ConstraintOperator? concept=FocusConcept;
		@Override public ParserRule getRule() { return rule; }
		
		//op=ConstraintOperator? concept=FocusConcept
		public Group getGroup() { return cGroup; }
		
		//op=ConstraintOperator?
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//ConstraintOperator
		public RuleCall getOpConstraintOperatorEnumRuleCall_0_0() { return cOpConstraintOperatorEnumRuleCall_0_0; }
		
		//concept=FocusConcept
		public Assignment getConceptAssignment_1() { return cConceptAssignment_1; }
		
		//FocusConcept
		public RuleCall getConceptFocusConceptParserRuleCall_1_0() { return cConceptFocusConceptParserRuleCall_1_0; }
	}
	public class FocusConceptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.FocusConcept");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMemberOfAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cMemberOfCircumflexAccentKeyword_0_0 = (Keyword)cMemberOfAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cConceptRefAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cConceptRefConceptReferenceParserRuleCall_1_0_0 = (RuleCall)cConceptRefAssignment_1_0.eContents().get(0);
		private final Assignment cWildcardAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cWildcardAsteriskKeyword_1_1_0 = (Keyword)cWildcardAssignment_1_1.eContents().get(0);
		
		//FocusConcept:
		//	memberOf?='^'? (conceptRef=ConceptReference | wildcard?='*');
		@Override public ParserRule getRule() { return rule; }
		
		//memberOf?='^'? (conceptRef=ConceptReference | wildcard?='*')
		public Group getGroup() { return cGroup; }
		
		//memberOf?='^'?
		public Assignment getMemberOfAssignment_0() { return cMemberOfAssignment_0; }
		
		//'^'
		public Keyword getMemberOfCircumflexAccentKeyword_0_0() { return cMemberOfCircumflexAccentKeyword_0_0; }
		
		//(conceptRef=ConceptReference | wildcard?='*')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//conceptRef=ConceptReference
		public Assignment getConceptRefAssignment_1_0() { return cConceptRefAssignment_1_0; }
		
		//ConceptReference
		public RuleCall getConceptRefConceptReferenceParserRuleCall_1_0_0() { return cConceptRefConceptReferenceParserRuleCall_1_0_0; }
		
		//wildcard?='*'
		public Assignment getWildcardAssignment_1_1() { return cWildcardAssignment_1_1; }
		
		//'*'
		public Keyword getWildcardAsteriskKeyword_1_1_0() { return cWildcardAsteriskKeyword_1_1_0; }
	}
	public class ConceptReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ConceptReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdConceptIDParserRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Assignment cTermAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTermTERM_STRINGTerminalRuleCall_1_0 = (RuleCall)cTermAssignment_1.eContents().get(0);
		
		//ConceptReference:
		//	id=ConceptID term=TERM_STRING?;
		@Override public ParserRule getRule() { return rule; }
		
		//id=ConceptID term=TERM_STRING?
		public Group getGroup() { return cGroup; }
		
		//id=ConceptID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }
		
		//ConceptID
		public RuleCall getIdConceptIDParserRuleCall_0_0() { return cIdConceptIDParserRuleCall_0_0; }
		
		//term=TERM_STRING?
		public Assignment getTermAssignment_1() { return cTermAssignment_1; }
		
		//TERM_STRING
		public RuleCall getTermTERM_STRINGTerminalRuleCall_1_0() { return cTermTERM_STRINGTerminalRuleCall_1_0; }
	}
	public class ConceptIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ConceptID");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ConceptID:
		//	INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}
	
	public class ExpressionComparisonOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ExpressionComparisonOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsSignKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQUALSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNOT_EQUALSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ExpressionComparisonOperator returns ComparisonOperator:
		//	EQUALS='=' |
		//	NOT_EQUALS='!=';
		public EnumRule getRule() { return rule; }
		
		//EQUALS='=' | NOT_EQUALS='!='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUALS='='
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }
		
		//'='
		public Keyword getEQUALSEqualsSignKeyword_0_0() { return cEQUALSEqualsSignKeyword_0_0; }
		
		//NOT_EQUALS='!='
		public EnumLiteralDeclaration getNOT_EQUALSEnumLiteralDeclaration_1() { return cNOT_EQUALSEnumLiteralDeclaration_1; }
		
		//'!='
		public Keyword getNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0() { return cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0; }
	}
	public class StringComparisonOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.StringComparisonOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsSignKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQUALSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNOT_EQUALSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum StringComparisonOperator returns ComparisonOperator:
		//	EQUALS='=' |
		//	NOT_EQUALS='!=';
		public EnumRule getRule() { return rule; }
		
		//EQUALS='=' | NOT_EQUALS='!='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUALS='='
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }
		
		//'='
		public Keyword getEQUALSEqualsSignKeyword_0_0() { return cEQUALSEqualsSignKeyword_0_0; }
		
		//NOT_EQUALS='!='
		public EnumLiteralDeclaration getNOT_EQUALSEnumLiteralDeclaration_1() { return cNOT_EQUALSEnumLiteralDeclaration_1; }
		
		//'!='
		public Keyword getNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0() { return cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0; }
	}
	public class NumericComparisonOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.NumericComparisonOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsSignKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQUALSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNOT_EQUALSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_THANEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLESS_THANLessThanSignKeyword_2_0 = (Keyword)cLESS_THANEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_THAN_EQUALSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESS_THAN_EQUALSLessThanSignEqualsSignKeyword_3_0 = (Keyword)cLESS_THAN_EQUALSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_THANEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGREATER_THANGreaterThanSignKeyword_4_0 = (Keyword)cGREATER_THANEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_THAN_EQUALSEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGREATER_THAN_EQUALSGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGREATER_THAN_EQUALSEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum NumericComparisonOperator returns ComparisonOperator:
		//	EQUALS='=' |
		//	NOT_EQUALS='!=' |
		//	LESS_THAN='<' |
		//	LESS_THAN_EQUALS='<=' |
		//	GREATER_THAN='>' |
		//	GREATER_THAN_EQUALS='>=';
		public EnumRule getRule() { return rule; }
		
		//EQUALS='=' | NOT_EQUALS='!=' | LESS_THAN='<' | LESS_THAN_EQUALS='<=' | GREATER_THAN='>' | GREATER_THAN_EQUALS='>='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUALS='='
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }
		
		//'='
		public Keyword getEQUALSEqualsSignKeyword_0_0() { return cEQUALSEqualsSignKeyword_0_0; }
		
		//NOT_EQUALS='!='
		public EnumLiteralDeclaration getNOT_EQUALSEnumLiteralDeclaration_1() { return cNOT_EQUALSEnumLiteralDeclaration_1; }
		
		//'!='
		public Keyword getNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0() { return cNOT_EQUALSExclamationMarkEqualsSignKeyword_1_0; }
		
		//LESS_THAN='<'
		public EnumLiteralDeclaration getLESS_THANEnumLiteralDeclaration_2() { return cLESS_THANEnumLiteralDeclaration_2; }
		
		//'<'
		public Keyword getLESS_THANLessThanSignKeyword_2_0() { return cLESS_THANLessThanSignKeyword_2_0; }
		
		//LESS_THAN_EQUALS='<='
		public EnumLiteralDeclaration getLESS_THAN_EQUALSEnumLiteralDeclaration_3() { return cLESS_THAN_EQUALSEnumLiteralDeclaration_3; }
		
		//'<='
		public Keyword getLESS_THAN_EQUALSLessThanSignEqualsSignKeyword_3_0() { return cLESS_THAN_EQUALSLessThanSignEqualsSignKeyword_3_0; }
		
		//GREATER_THAN='>'
		public EnumLiteralDeclaration getGREATER_THANEnumLiteralDeclaration_4() { return cGREATER_THANEnumLiteralDeclaration_4; }
		
		//'>'
		public Keyword getGREATER_THANGreaterThanSignKeyword_4_0() { return cGREATER_THANGreaterThanSignKeyword_4_0; }
		
		//GREATER_THAN_EQUALS='>='
		public EnumLiteralDeclaration getGREATER_THAN_EQUALSEnumLiteralDeclaration_5() { return cGREATER_THAN_EQUALSEnumLiteralDeclaration_5; }
		
		//'>='
		public Keyword getGREATER_THAN_EQUALSGreaterThanSignEqualsSignKeyword_5_0() { return cGREATER_THAN_EQUALSGreaterThanSignEqualsSignKeyword_5_0; }
	}
	public class ConstraintOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ConstraintOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDESCENDANTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDESCENDANTLessThanSignKeyword_0_0 = (Keyword)cDESCENDANTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDESCENDANT_OR_SELFEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDESCENDANT_OR_SELFLessThanSignLessThanSignKeyword_1_0 = (Keyword)cDESCENDANT_OR_SELFEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cANCESTOREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cANCESTORGreaterThanSignKeyword_2_0 = (Keyword)cANCESTOREnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cANCESTOR_OR_SELFEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cANCESTOR_OR_SELFGreaterThanSignGreaterThanSignKeyword_3_0 = (Keyword)cANCESTOR_OR_SELFEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ConstraintOperator:
		//	DESCENDANT='<' |
		//	DESCENDANT_OR_SELF='<<' |
		//	ANCESTOR='>' |
		//	ANCESTOR_OR_SELF='>>';
		public EnumRule getRule() { return rule; }
		
		//DESCENDANT='<' | DESCENDANT_OR_SELF='<<' | ANCESTOR='>' | ANCESTOR_OR_SELF='>>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DESCENDANT='<'
		public EnumLiteralDeclaration getDESCENDANTEnumLiteralDeclaration_0() { return cDESCENDANTEnumLiteralDeclaration_0; }
		
		//'<'
		public Keyword getDESCENDANTLessThanSignKeyword_0_0() { return cDESCENDANTLessThanSignKeyword_0_0; }
		
		//DESCENDANT_OR_SELF='<<'
		public EnumLiteralDeclaration getDESCENDANT_OR_SELFEnumLiteralDeclaration_1() { return cDESCENDANT_OR_SELFEnumLiteralDeclaration_1; }
		
		//'<<'
		public Keyword getDESCENDANT_OR_SELFLessThanSignLessThanSignKeyword_1_0() { return cDESCENDANT_OR_SELFLessThanSignLessThanSignKeyword_1_0; }
		
		//ANCESTOR='>'
		public EnumLiteralDeclaration getANCESTOREnumLiteralDeclaration_2() { return cANCESTOREnumLiteralDeclaration_2; }
		
		//'>'
		public Keyword getANCESTORGreaterThanSignKeyword_2_0() { return cANCESTORGreaterThanSignKeyword_2_0; }
		
		//ANCESTOR_OR_SELF='>>'
		public EnumLiteralDeclaration getANCESTOR_OR_SELFEnumLiteralDeclaration_3() { return cANCESTOR_OR_SELFEnumLiteralDeclaration_3; }
		
		//'>>'
		public Keyword getANCESTOR_OR_SELFGreaterThanSignGreaterThanSignKeyword_3_0() { return cANCESTOR_OR_SELFGreaterThanSignGreaterThanSignKeyword_3_0; }
	}
	public class AttributeOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.AttributeOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDESCENDANTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDESCENDANTLessThanSignKeyword_0_0 = (Keyword)cDESCENDANTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDESCENDANT_OR_SELFEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDESCENDANT_OR_SELFLessThanSignLessThanSignKeyword_1_0 = (Keyword)cDESCENDANT_OR_SELFEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AttributeOperator:
		//	DESCENDANT='<' |
		//	DESCENDANT_OR_SELF='<<';
		public EnumRule getRule() { return rule; }
		
		//DESCENDANT='<' | DESCENDANT_OR_SELF='<<'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DESCENDANT='<'
		public EnumLiteralDeclaration getDESCENDANTEnumLiteralDeclaration_0() { return cDESCENDANTEnumLiteralDeclaration_0; }
		
		//'<'
		public Keyword getDESCENDANTLessThanSignKeyword_0_0() { return cDESCENDANTLessThanSignKeyword_0_0; }
		
		//DESCENDANT_OR_SELF='<<'
		public EnumLiteralDeclaration getDESCENDANT_OR_SELFEnumLiteralDeclaration_1() { return cDESCENDANT_OR_SELFEnumLiteralDeclaration_1; }
		
		//'<<'
		public Keyword getDESCENDANT_OR_SELFLessThanSignLessThanSignKeyword_1_0() { return cDESCENDANT_OR_SELFLessThanSignLessThanSignKeyword_1_0; }
	}
	public class BinaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.BinaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCONJUNCTIONEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCONJUNCTIONANDKeyword_0_0 = (Keyword)cCONJUNCTIONEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCONJUNCTIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCONJUNCTIONCommaKeyword_1_0 = (Keyword)cCONJUNCTIONEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDISJUNCTIONEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDISJUNCTIONORKeyword_2_0 = (Keyword)cDISJUNCTIONEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cEXCLUSIONEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cEXCLUSIONMINUSKeyword_3_0 = (Keyword)cEXCLUSIONEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum BinaryOperator:
		//	CONJUNCTION='AND' |
		//	CONJUNCTION=',' |
		//	DISJUNCTION='OR' |
		//	EXCLUSION='MINUS';
		public EnumRule getRule() { return rule; }
		
		//CONJUNCTION='AND' | CONJUNCTION=',' | DISJUNCTION='OR' | EXCLUSION='MINUS'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CONJUNCTION='AND'
		public EnumLiteralDeclaration getCONJUNCTIONEnumLiteralDeclaration_0() { return cCONJUNCTIONEnumLiteralDeclaration_0; }
		
		//'AND'
		public Keyword getCONJUNCTIONANDKeyword_0_0() { return cCONJUNCTIONANDKeyword_0_0; }
		
		//CONJUNCTION=','
		public EnumLiteralDeclaration getCONJUNCTIONEnumLiteralDeclaration_1() { return cCONJUNCTIONEnumLiteralDeclaration_1; }
		
		//','
		public Keyword getCONJUNCTIONCommaKeyword_1_0() { return cCONJUNCTIONCommaKeyword_1_0; }
		
		//DISJUNCTION='OR'
		public EnumLiteralDeclaration getDISJUNCTIONEnumLiteralDeclaration_2() { return cDISJUNCTIONEnumLiteralDeclaration_2; }
		
		//'OR'
		public Keyword getDISJUNCTIONORKeyword_2_0() { return cDISJUNCTIONORKeyword_2_0; }
		
		//EXCLUSION='MINUS'
		public EnumLiteralDeclaration getEXCLUSIONEnumLiteralDeclaration_3() { return cEXCLUSIONEnumLiteralDeclaration_3; }
		
		//'MINUS'
		public Keyword getEXCLUSIONMINUSKeyword_3_0() { return cEXCLUSIONMINUSKeyword_3_0; }
	}
	public class ConjunctionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ConjunctionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCONJUNCTIONEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCONJUNCTIONANDKeyword_0_0 = (Keyword)cCONJUNCTIONEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCONJUNCTIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCONJUNCTIONCommaKeyword_1_0 = (Keyword)cCONJUNCTIONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ConjunctionOperator returns BinaryOperator:
		//	CONJUNCTION='AND' |
		//	CONJUNCTION=',';
		public EnumRule getRule() { return rule; }
		
		//CONJUNCTION='AND' | CONJUNCTION=','
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CONJUNCTION='AND'
		public EnumLiteralDeclaration getCONJUNCTIONEnumLiteralDeclaration_0() { return cCONJUNCTIONEnumLiteralDeclaration_0; }
		
		//'AND'
		public Keyword getCONJUNCTIONANDKeyword_0_0() { return cCONJUNCTIONANDKeyword_0_0; }
		
		//CONJUNCTION=','
		public EnumLiteralDeclaration getCONJUNCTIONEnumLiteralDeclaration_1() { return cCONJUNCTIONEnumLiteralDeclaration_1; }
		
		//','
		public Keyword getCONJUNCTIONCommaKeyword_1_0() { return cCONJUNCTIONCommaKeyword_1_0; }
	}
	public class DisjunctionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.DisjunctionOperator");
		private final EnumLiteralDeclaration cDISJUNCTIONEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cDISJUNCTIONORKeyword_0 = (Keyword)cDISJUNCTIONEnumLiteralDeclaration.eContents().get(0);
		
		//enum DisjunctionOperator returns BinaryOperator:
		//	DISJUNCTION='OR';
		public EnumRule getRule() { return rule; }
		
		//DISJUNCTION='OR'
		public EnumLiteralDeclaration getDISJUNCTIONEnumLiteralDeclaration() { return cDISJUNCTIONEnumLiteralDeclaration; }
		
		//'OR'
		public Keyword getDISJUNCTIONORKeyword_0() { return cDISJUNCTIONORKeyword_0; }
	}
	public class ExclusionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.ExclusionOperator");
		private final EnumLiteralDeclaration cEXCLUSIONEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cEXCLUSIONMINUSKeyword_0 = (Keyword)cEXCLUSIONEnumLiteralDeclaration.eContents().get(0);
		
		//enum ExclusionOperator returns BinaryOperator:
		//	EXCLUSION='MINUS';
		public EnumRule getRule() { return rule; }
		
		//EXCLUSION='MINUS'
		public EnumLiteralDeclaration getEXCLUSIONEnumLiteralDeclaration() { return cEXCLUSIONEnumLiteralDeclaration; }
		
		//'MINUS'
		public Keyword getEXCLUSIONMINUSKeyword_0() { return cEXCLUSIONMINUSKeyword_0; }
	}
	
	private final ScriptElements pScript;
	private final ExpressionConstraintElements pExpressionConstraint;
	private final ExclusionExpressionConstraintElements pExclusionExpressionConstraint;
	private final DisjunctionExpressionConstraintElements pDisjunctionExpressionConstraint;
	private final ConjunctionExpressionConstraintElements pConjunctionExpressionConstraint;
	private final RefinedExpressionConstraintElements pRefinedExpressionConstraint;
	private final RefinementElements pRefinement;
	private final DisjunctionRefinementSetElements pDisjunctionRefinementSet;
	private final ConjunctionRefinementSetElements pConjunctionRefinementSet;
	private final SubRefinementElements pSubRefinement;
	private final AttributeSetRefinementElements pAttributeSetRefinement;
	private final AttributeGroupRefinementElements pAttributeGroupRefinement;
	private final DisjunctionAttributeSetElements pDisjunctionAttributeSet;
	private final ConjunctionAttributeSetElements pConjunctionAttributeSet;
	private final PrimaryAttributeSetElements pPrimaryAttributeSet;
	private final AttributeElements pAttribute;
	private final CardinalityElements pCardinality;
	private final AttributeValueElements pAttributeValue;
	private final StringValueElements pStringValue;
	private final NumericValueElements pNumericValue;
	private final NumberElements pNumber;
	private final ExpressionValueElements pExpressionValue;
	private final ExpressionComparisonOperatorElements eExpressionComparisonOperator;
	private final StringComparisonOperatorElements eStringComparisonOperator;
	private final NumericComparisonOperatorElements eNumericComparisonOperator;
	private final ParenthesizedAttributeSetElements pParenthesizedAttributeSet;
	private final AttributeGroupElements pAttributeGroup;
	private final ParenthesizedRefinementElements pParenthesizedRefinement;
	private final PrimaryExpressionConstraintElements pPrimaryExpressionConstraint;
	private final SimpleExpressionConstraintElements pSimpleExpressionConstraint;
	private final ConstraintOperatorElements eConstraintOperator;
	private final AttributeOperatorElements eAttributeOperator;
	private final FocusConceptElements pFocusConcept;
	private final ConceptReferenceElements pConceptReference;
	private final BinaryOperatorElements eBinaryOperator;
	private final ConjunctionOperatorElements eConjunctionOperator;
	private final DisjunctionOperatorElements eDisjunctionOperator;
	private final ExclusionOperatorElements eExclusionOperator;
	private final ConceptIDElements pConceptID;
	private final TerminalRule tTERM_STRING;
	private final TerminalRule tREVERSE;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public EclGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pScript = new ScriptElements();
		this.pExpressionConstraint = new ExpressionConstraintElements();
		this.pExclusionExpressionConstraint = new ExclusionExpressionConstraintElements();
		this.pDisjunctionExpressionConstraint = new DisjunctionExpressionConstraintElements();
		this.pConjunctionExpressionConstraint = new ConjunctionExpressionConstraintElements();
		this.pRefinedExpressionConstraint = new RefinedExpressionConstraintElements();
		this.pRefinement = new RefinementElements();
		this.pDisjunctionRefinementSet = new DisjunctionRefinementSetElements();
		this.pConjunctionRefinementSet = new ConjunctionRefinementSetElements();
		this.pSubRefinement = new SubRefinementElements();
		this.pAttributeSetRefinement = new AttributeSetRefinementElements();
		this.pAttributeGroupRefinement = new AttributeGroupRefinementElements();
		this.pDisjunctionAttributeSet = new DisjunctionAttributeSetElements();
		this.pConjunctionAttributeSet = new ConjunctionAttributeSetElements();
		this.pPrimaryAttributeSet = new PrimaryAttributeSetElements();
		this.pAttribute = new AttributeElements();
		this.pCardinality = new CardinalityElements();
		this.pAttributeValue = new AttributeValueElements();
		this.pStringValue = new StringValueElements();
		this.pNumericValue = new NumericValueElements();
		this.pNumber = new NumberElements();
		this.pExpressionValue = new ExpressionValueElements();
		this.eExpressionComparisonOperator = new ExpressionComparisonOperatorElements();
		this.eStringComparisonOperator = new StringComparisonOperatorElements();
		this.eNumericComparisonOperator = new NumericComparisonOperatorElements();
		this.pParenthesizedAttributeSet = new ParenthesizedAttributeSetElements();
		this.pAttributeGroup = new AttributeGroupElements();
		this.pParenthesizedRefinement = new ParenthesizedRefinementElements();
		this.pPrimaryExpressionConstraint = new PrimaryExpressionConstraintElements();
		this.pSimpleExpressionConstraint = new SimpleExpressionConstraintElements();
		this.eConstraintOperator = new ConstraintOperatorElements();
		this.eAttributeOperator = new AttributeOperatorElements();
		this.pFocusConcept = new FocusConceptElements();
		this.pConceptReference = new ConceptReferenceElements();
		this.eBinaryOperator = new BinaryOperatorElements();
		this.eConjunctionOperator = new ConjunctionOperatorElements();
		this.eDisjunctionOperator = new DisjunctionOperatorElements();
		this.eExclusionOperator = new ExclusionOperatorElements();
		this.pConceptID = new ConceptIDElements();
		this.tTERM_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.TERM_STRING");
		this.tREVERSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.akitta.snomed.ecl.Ecl.REVERSE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.akitta.snomed.ecl.Ecl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Script:
	//	constraint=ExpressionConstraint?;
	public ScriptElements getScriptAccess() {
		return pScript;
	}
	
	public ParserRule getScriptRule() {
		return getScriptAccess().getRule();
	}
	
	//ExpressionConstraint:
	//	ExclusionExpressionConstraint;
	public ExpressionConstraintElements getExpressionConstraintAccess() {
		return pExpressionConstraint;
	}
	
	public ParserRule getExpressionConstraintRule() {
		return getExpressionConstraintAccess().getRule();
	}
	
	//ExclusionExpressionConstraint ExpressionConstraint:
	//	DisjunctionExpressionConstraint (=> ({ExclusionExpressionConstraint.left=current} op=ExclusionOperator)
	//	right=DisjunctionExpressionConstraint)*
	public ExclusionExpressionConstraintElements getExclusionExpressionConstraintAccess() {
		return pExclusionExpressionConstraint;
	}
	
	public ParserRule getExclusionExpressionConstraintRule() {
		return getExclusionExpressionConstraintAccess().getRule();
	}
	
	//DisjunctionExpressionConstraint ExpressionConstraint:
	//	ConjunctionExpressionConstraint (=> ({DisjunctionExpressionConstraint.left=current} op=DisjunctionOperator)
	//	right=ConjunctionExpressionConstraint)*
	public DisjunctionExpressionConstraintElements getDisjunctionExpressionConstraintAccess() {
		return pDisjunctionExpressionConstraint;
	}
	
	public ParserRule getDisjunctionExpressionConstraintRule() {
		return getDisjunctionExpressionConstraintAccess().getRule();
	}
	
	//ConjunctionExpressionConstraint ExpressionConstraint:
	//	RefinedExpressionConstraint (=> ({ConjunctionExpressionConstraint.left=current} op=ConjunctionOperator)
	//	right=RefinedExpressionConstraint)*
	public ConjunctionExpressionConstraintElements getConjunctionExpressionConstraintAccess() {
		return pConjunctionExpressionConstraint;
	}
	
	public ParserRule getConjunctionExpressionConstraintRule() {
		return getConjunctionExpressionConstraintAccess().getRule();
	}
	
	//RefinedExpressionConstraint ExpressionConstraint:
	//	PrimaryExpressionConstraint ({RefinedExpressionConstraint.target=current} ':' refinement=Refinement)?
	public RefinedExpressionConstraintElements getRefinedExpressionConstraintAccess() {
		return pRefinedExpressionConstraint;
	}
	
	public ParserRule getRefinedExpressionConstraintRule() {
		return getRefinedExpressionConstraintAccess().getRule();
	}
	
	//Refinement:
	//	DisjunctionRefinementSet;
	public RefinementElements getRefinementAccess() {
		return pRefinement;
	}
	
	public ParserRule getRefinementRule() {
		return getRefinementAccess().getRule();
	}
	
	//DisjunctionRefinementSet Refinement:
	//	ConjunctionRefinementSet (=> ({DisjunctionRefinementSet.left=current} op=DisjunctionOperator)
	//	right=ConjunctionRefinementSet)*
	public DisjunctionRefinementSetElements getDisjunctionRefinementSetAccess() {
		return pDisjunctionRefinementSet;
	}
	
	public ParserRule getDisjunctionRefinementSetRule() {
		return getDisjunctionRefinementSetAccess().getRule();
	}
	
	//ConjunctionRefinementSet Refinement:
	//	SubRefinement (=> ({ConjunctionRefinementSet.left=current} op=ConjunctionOperator) right=SubRefinement)*
	public ConjunctionRefinementSetElements getConjunctionRefinementSetAccess() {
		return pConjunctionRefinementSet;
	}
	
	public ParserRule getConjunctionRefinementSetRule() {
		return getConjunctionRefinementSetAccess().getRule();
	}
	
	//SubRefinement Refinement:
	//	AttributeSetRefinement
	//	| AttributeGroupRefinement
	//	| ParenthesizedRefinement
	public SubRefinementElements getSubRefinementAccess() {
		return pSubRefinement;
	}
	
	public ParserRule getSubRefinementRule() {
		return getSubRefinementAccess().getRule();
	}
	
	//AttributeSetRefinement:
	//	attributeSet=DisjunctionAttributeSet;
	public AttributeSetRefinementElements getAttributeSetRefinementAccess() {
		return pAttributeSetRefinement;
	}
	
	public ParserRule getAttributeSetRefinementRule() {
		return getAttributeSetRefinementAccess().getRule();
	}
	
	//AttributeGroupRefinement:
	//	attributeGroup=AttributeGroup;
	public AttributeGroupRefinementElements getAttributeGroupRefinementAccess() {
		return pAttributeGroupRefinement;
	}
	
	public ParserRule getAttributeGroupRefinementRule() {
		return getAttributeGroupRefinementAccess().getRule();
	}
	
	//DisjunctionAttributeSet AttributeSet:
	//	ConjunctionAttributeSet (=> ({DisjunctionAttributeSet.left=current} op=DisjunctionOperator)
	//	right=ConjunctionAttributeSet)*
	public DisjunctionAttributeSetElements getDisjunctionAttributeSetAccess() {
		return pDisjunctionAttributeSet;
	}
	
	public ParserRule getDisjunctionAttributeSetRule() {
		return getDisjunctionAttributeSetAccess().getRule();
	}
	
	//ConjunctionAttributeSet AttributeSet:
	//	PrimaryAttributeSet (=> ({ConjunctionAttributeSet.left=current} op=ConjunctionOperator) right=PrimaryAttributeSet)*
	public ConjunctionAttributeSetElements getConjunctionAttributeSetAccess() {
		return pConjunctionAttributeSet;
	}
	
	public ParserRule getConjunctionAttributeSetRule() {
		return getConjunctionAttributeSetAccess().getRule();
	}
	
	//PrimaryAttributeSet AttributeSet:
	//	ParenthesizedAttributeSet | Attribute
	public PrimaryAttributeSetElements getPrimaryAttributeSetAccess() {
		return pPrimaryAttributeSet;
	}
	
	public ParserRule getPrimaryAttributeSetRule() {
		return getPrimaryAttributeSetAccess().getRule();
	}
	
	//Attribute:
	//	cardinality=Cardinality?
	//	reversed?=REVERSE?
	//	op=AttributeOperator? (conceptRef=ConceptReference | wildcard?='*') value=AttributeValue;
	public AttributeElements getAttributeAccess() {
		return pAttribute;
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}
	
	//Cardinality:
	//	'[' from=INT '..' (to=INT | many?='*') ']';
	public CardinalityElements getCardinalityAccess() {
		return pCardinality;
	}
	
	public ParserRule getCardinalityRule() {
		return getCardinalityAccess().getRule();
	}
	
	//AttributeValue:
	//	ExpressionValue | NumericValue | StringValue;
	public AttributeValueElements getAttributeValueAccess() {
		return pAttributeValue;
	}
	
	public ParserRule getAttributeValueRule() {
		return getAttributeValueAccess().getRule();
	}
	
	//StringValue:
	//	op=StringComparisonOperator value=STRING;
	public StringValueElements getStringValueAccess() {
		return pStringValue;
	}
	
	public ParserRule getStringValueRule() {
		return getStringValueAccess().getRule();
	}
	
	//NumericValue:
	//	op=NumericComparisonOperator '#' value=Number;
	public NumericValueElements getNumericValueAccess() {
		return pNumericValue;
	}
	
	public ParserRule getNumericValueRule() {
		return getNumericValueAccess().getRule();
	}
	
	//Number ecore::EBigDecimal:
	//	INT ('.' INT)?
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//ExpressionValue:
	//	op=ExpressionComparisonOperator value=PrimaryExpressionConstraint;
	public ExpressionValueElements getExpressionValueAccess() {
		return pExpressionValue;
	}
	
	public ParserRule getExpressionValueRule() {
		return getExpressionValueAccess().getRule();
	}
	
	//enum ExpressionComparisonOperator returns ComparisonOperator:
	//	EQUALS='=' |
	//	NOT_EQUALS='!=';
	public ExpressionComparisonOperatorElements getExpressionComparisonOperatorAccess() {
		return eExpressionComparisonOperator;
	}
	
	public EnumRule getExpressionComparisonOperatorRule() {
		return getExpressionComparisonOperatorAccess().getRule();
	}
	
	//enum StringComparisonOperator returns ComparisonOperator:
	//	EQUALS='=' |
	//	NOT_EQUALS='!=';
	public StringComparisonOperatorElements getStringComparisonOperatorAccess() {
		return eStringComparisonOperator;
	}
	
	public EnumRule getStringComparisonOperatorRule() {
		return getStringComparisonOperatorAccess().getRule();
	}
	
	//enum NumericComparisonOperator returns ComparisonOperator:
	//	EQUALS='=' |
	//	NOT_EQUALS='!=' |
	//	LESS_THAN='<' |
	//	LESS_THAN_EQUALS='<=' |
	//	GREATER_THAN='>' |
	//	GREATER_THAN_EQUALS='>=';
	public NumericComparisonOperatorElements getNumericComparisonOperatorAccess() {
		return eNumericComparisonOperator;
	}
	
	public EnumRule getNumericComparisonOperatorRule() {
		return getNumericComparisonOperatorAccess().getRule();
	}
	
	//ParenthesizedAttributeSet AttributeSet:
	//	'(' DisjunctionAttributeSet ')'
	public ParenthesizedAttributeSetElements getParenthesizedAttributeSetAccess() {
		return pParenthesizedAttributeSet;
	}
	
	public ParserRule getParenthesizedAttributeSetRule() {
		return getParenthesizedAttributeSetAccess().getRule();
	}
	
	//AttributeGroup:
	//	cardinality=Cardinality? '{' attributeSet=DisjunctionAttributeSet '}';
	public AttributeGroupElements getAttributeGroupAccess() {
		return pAttributeGroup;
	}
	
	public ParserRule getAttributeGroupRule() {
		return getAttributeGroupAccess().getRule();
	}
	
	//ParenthesizedRefinement Refinement:
	//	'(' Refinement ')'
	public ParenthesizedRefinementElements getParenthesizedRefinementAccess() {
		return pParenthesizedRefinement;
	}
	
	public ParserRule getParenthesizedRefinementRule() {
		return getParenthesizedRefinementAccess().getRule();
	}
	
	//PrimaryExpressionConstraint ExpressionConstraint:
	//	SimpleExpressionConstraint |
	//	'(' ExpressionConstraint {ParenthesizedExpressionConstraint.^current=current} ')'
	public PrimaryExpressionConstraintElements getPrimaryExpressionConstraintAccess() {
		return pPrimaryExpressionConstraint;
	}
	
	public ParserRule getPrimaryExpressionConstraintRule() {
		return getPrimaryExpressionConstraintAccess().getRule();
	}
	
	//SimpleExpressionConstraint:
	//	op=ConstraintOperator? concept=FocusConcept;
	public SimpleExpressionConstraintElements getSimpleExpressionConstraintAccess() {
		return pSimpleExpressionConstraint;
	}
	
	public ParserRule getSimpleExpressionConstraintRule() {
		return getSimpleExpressionConstraintAccess().getRule();
	}
	
	//enum ConstraintOperator:
	//	DESCENDANT='<' |
	//	DESCENDANT_OR_SELF='<<' |
	//	ANCESTOR='>' |
	//	ANCESTOR_OR_SELF='>>';
	public ConstraintOperatorElements getConstraintOperatorAccess() {
		return eConstraintOperator;
	}
	
	public EnumRule getConstraintOperatorRule() {
		return getConstraintOperatorAccess().getRule();
	}
	
	//enum AttributeOperator:
	//	DESCENDANT='<' |
	//	DESCENDANT_OR_SELF='<<';
	public AttributeOperatorElements getAttributeOperatorAccess() {
		return eAttributeOperator;
	}
	
	public EnumRule getAttributeOperatorRule() {
		return getAttributeOperatorAccess().getRule();
	}
	
	//FocusConcept:
	//	memberOf?='^'? (conceptRef=ConceptReference | wildcard?='*');
	public FocusConceptElements getFocusConceptAccess() {
		return pFocusConcept;
	}
	
	public ParserRule getFocusConceptRule() {
		return getFocusConceptAccess().getRule();
	}
	
	//ConceptReference:
	//	id=ConceptID term=TERM_STRING?;
	public ConceptReferenceElements getConceptReferenceAccess() {
		return pConceptReference;
	}
	
	public ParserRule getConceptReferenceRule() {
		return getConceptReferenceAccess().getRule();
	}
	
	//enum BinaryOperator:
	//	CONJUNCTION='AND' |
	//	CONJUNCTION=',' |
	//	DISJUNCTION='OR' |
	//	EXCLUSION='MINUS';
	public BinaryOperatorElements getBinaryOperatorAccess() {
		return eBinaryOperator;
	}
	
	public EnumRule getBinaryOperatorRule() {
		return getBinaryOperatorAccess().getRule();
	}
	
	//enum ConjunctionOperator returns BinaryOperator:
	//	CONJUNCTION='AND' |
	//	CONJUNCTION=',';
	public ConjunctionOperatorElements getConjunctionOperatorAccess() {
		return eConjunctionOperator;
	}
	
	public EnumRule getConjunctionOperatorRule() {
		return getConjunctionOperatorAccess().getRule();
	}
	
	//enum DisjunctionOperator returns BinaryOperator:
	//	DISJUNCTION='OR';
	public DisjunctionOperatorElements getDisjunctionOperatorAccess() {
		return eDisjunctionOperator;
	}
	
	public EnumRule getDisjunctionOperatorRule() {
		return getDisjunctionOperatorAccess().getRule();
	}
	
	//enum ExclusionOperator returns BinaryOperator:
	//	EXCLUSION='MINUS';
	public ExclusionOperatorElements getExclusionOperatorAccess() {
		return eExclusionOperator;
	}
	
	public EnumRule getExclusionOperatorRule() {
		return getExclusionOperatorAccess().getRule();
	}
	
	//ConceptID:
	//	INT;
	public ConceptIDElements getConceptIDAccess() {
		return pConceptID;
	}
	
	public ParserRule getConceptIDRule() {
		return getConceptIDAccess().getRule();
	}
	
	//terminal TERM_STRING:
	//	"|" !"|"* "|";
	public TerminalRule getTERM_STRINGRule() {
		return tTERM_STRING;
	}
	
	//terminal REVERSE:
	//	'R';
	public TerminalRule getREVERSERule() {
		return tREVERSE;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
