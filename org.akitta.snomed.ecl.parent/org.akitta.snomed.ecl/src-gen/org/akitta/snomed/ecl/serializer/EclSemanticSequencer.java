/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package org.akitta.snomed.ecl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.akitta.snomed.ecl.model.ecl.Attribute;
import org.akitta.snomed.ecl.model.ecl.AttributeGroup;
import org.akitta.snomed.ecl.model.ecl.AttributeGroupRefinement;
import org.akitta.snomed.ecl.model.ecl.AttributeSetRefinement;
import org.akitta.snomed.ecl.model.ecl.Cardinality;
import org.akitta.snomed.ecl.model.ecl.ConceptReference;
import org.akitta.snomed.ecl.model.ecl.ConjunctionAttributeSet;
import org.akitta.snomed.ecl.model.ecl.ConjunctionExpressionConstraint;
import org.akitta.snomed.ecl.model.ecl.ConjunctionRefinementSet;
import org.akitta.snomed.ecl.model.ecl.DisjunctionAttributeSet;
import org.akitta.snomed.ecl.model.ecl.DisjunctionExpressionConstraint;
import org.akitta.snomed.ecl.model.ecl.DisjunctionRefinementSet;
import org.akitta.snomed.ecl.model.ecl.EclPackage;
import org.akitta.snomed.ecl.model.ecl.ExclusionExpressionConstraint;
import org.akitta.snomed.ecl.model.ecl.ExpressionValue;
import org.akitta.snomed.ecl.model.ecl.FocusConcept;
import org.akitta.snomed.ecl.model.ecl.NumericValue;
import org.akitta.snomed.ecl.model.ecl.ParenthesizedExpressionConstraint;
import org.akitta.snomed.ecl.model.ecl.RefinedExpressionConstraint;
import org.akitta.snomed.ecl.model.ecl.Script;
import org.akitta.snomed.ecl.model.ecl.SimpleExpressionConstraint;
import org.akitta.snomed.ecl.model.ecl.StringValue;
import org.akitta.snomed.ecl.services.EclGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EclSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EclGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EclPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EclPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case EclPackage.ATTRIBUTE_GROUP:
				sequence_AttributeGroup(context, (AttributeGroup) semanticObject); 
				return; 
			case EclPackage.ATTRIBUTE_GROUP_REFINEMENT:
				sequence_AttributeGroupRefinement(context, (AttributeGroupRefinement) semanticObject); 
				return; 
			case EclPackage.ATTRIBUTE_SET_REFINEMENT:
				sequence_AttributeSetRefinement(context, (AttributeSetRefinement) semanticObject); 
				return; 
			case EclPackage.CARDINALITY:
				sequence_Cardinality(context, (Cardinality) semanticObject); 
				return; 
			case EclPackage.CONCEPT_REFERENCE:
				sequence_ConceptReference(context, (ConceptReference) semanticObject); 
				return; 
			case EclPackage.CONJUNCTION_ATTRIBUTE_SET:
				sequence_ConjunctionAttributeSet(context, (ConjunctionAttributeSet) semanticObject); 
				return; 
			case EclPackage.CONJUNCTION_EXPRESSION_CONSTRAINT:
				sequence_ConjunctionExpressionConstraint(context, (ConjunctionExpressionConstraint) semanticObject); 
				return; 
			case EclPackage.CONJUNCTION_REFINEMENT_SET:
				sequence_ConjunctionRefinementSet(context, (ConjunctionRefinementSet) semanticObject); 
				return; 
			case EclPackage.DISJUNCTION_ATTRIBUTE_SET:
				sequence_DisjunctionAttributeSet(context, (DisjunctionAttributeSet) semanticObject); 
				return; 
			case EclPackage.DISJUNCTION_EXPRESSION_CONSTRAINT:
				sequence_DisjunctionExpressionConstraint(context, (DisjunctionExpressionConstraint) semanticObject); 
				return; 
			case EclPackage.DISJUNCTION_REFINEMENT_SET:
				sequence_DisjunctionRefinementSet(context, (DisjunctionRefinementSet) semanticObject); 
				return; 
			case EclPackage.EXCLUSION_EXPRESSION_CONSTRAINT:
				sequence_ExclusionExpressionConstraint(context, (ExclusionExpressionConstraint) semanticObject); 
				return; 
			case EclPackage.EXPRESSION_VALUE:
				sequence_ExpressionValue(context, (ExpressionValue) semanticObject); 
				return; 
			case EclPackage.FOCUS_CONCEPT:
				sequence_FocusConcept(context, (FocusConcept) semanticObject); 
				return; 
			case EclPackage.NUMERIC_VALUE:
				sequence_NumericValue(context, (NumericValue) semanticObject); 
				return; 
			case EclPackage.PARENTHESIZED_EXPRESSION_CONSTRAINT:
				sequence_PrimaryExpressionConstraint(context, (ParenthesizedExpressionConstraint) semanticObject); 
				return; 
			case EclPackage.REFINED_EXPRESSION_CONSTRAINT:
				sequence_RefinedExpressionConstraint(context, (RefinedExpressionConstraint) semanticObject); 
				return; 
			case EclPackage.SCRIPT:
				sequence_Script(context, (Script) semanticObject); 
				return; 
			case EclPackage.SIMPLE_EXPRESSION_CONSTRAINT:
				sequence_SimpleExpressionConstraint(context, (SimpleExpressionConstraint) semanticObject); 
				return; 
			case EclPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Refinement returns AttributeGroupRefinement
	 *     DisjunctionRefinementSet returns AttributeGroupRefinement
	 *     DisjunctionRefinementSet.DisjunctionRefinementSet_1_0_0_0 returns AttributeGroupRefinement
	 *     ConjunctionRefinementSet returns AttributeGroupRefinement
	 *     ConjunctionRefinementSet.ConjunctionRefinementSet_1_0_0_0 returns AttributeGroupRefinement
	 *     SubRefinement returns AttributeGroupRefinement
	 *     AttributeGroupRefinement returns AttributeGroupRefinement
	 *     ParenthesizedRefinement returns AttributeGroupRefinement
	 *
	 * Constraint:
	 *     attributeGroup=AttributeGroup
	 */
	protected void sequence_AttributeGroupRefinement(ISerializationContext context, AttributeGroupRefinement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.ATTRIBUTE_GROUP_REFINEMENT__ATTRIBUTE_GROUP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.ATTRIBUTE_GROUP_REFINEMENT__ATTRIBUTE_GROUP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeGroupRefinementAccess().getAttributeGroupAttributeGroupParserRuleCall_0(), semanticObject.getAttributeGroup());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeGroup returns AttributeGroup
	 *
	 * Constraint:
	 *     (cardinality=Cardinality? attributeSet=DisjunctionAttributeSet)
	 */
	protected void sequence_AttributeGroup(ISerializationContext context, AttributeGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Refinement returns AttributeSetRefinement
	 *     DisjunctionRefinementSet returns AttributeSetRefinement
	 *     DisjunctionRefinementSet.DisjunctionRefinementSet_1_0_0_0 returns AttributeSetRefinement
	 *     ConjunctionRefinementSet returns AttributeSetRefinement
	 *     ConjunctionRefinementSet.ConjunctionRefinementSet_1_0_0_0 returns AttributeSetRefinement
	 *     SubRefinement returns AttributeSetRefinement
	 *     AttributeSetRefinement returns AttributeSetRefinement
	 *     ParenthesizedRefinement returns AttributeSetRefinement
	 *
	 * Constraint:
	 *     attributeSet=DisjunctionAttributeSet
	 */
	protected void sequence_AttributeSetRefinement(ISerializationContext context, AttributeSetRefinement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.ATTRIBUTE_SET_REFINEMENT__ATTRIBUTE_SET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.ATTRIBUTE_SET_REFINEMENT__ATTRIBUTE_SET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeSetRefinementAccess().getAttributeSetDisjunctionAttributeSetParserRuleCall_0(), semanticObject.getAttributeSet());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DisjunctionAttributeSet returns Attribute
	 *     DisjunctionAttributeSet.DisjunctionAttributeSet_1_0_0_0 returns Attribute
	 *     ConjunctionAttributeSet returns Attribute
	 *     ConjunctionAttributeSet.ConjunctionAttributeSet_1_0_0_0 returns Attribute
	 *     PrimaryAttributeSet returns Attribute
	 *     Attribute returns Attribute
	 *     ParenthesizedAttributeSet returns Attribute
	 *
	 * Constraint:
	 *     (cardinality=Cardinality? reversed?=REVERSE? op=AttributeOperator? (conceptRef=ConceptReference | wildcard?='*') value=AttributeValue)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cardinality returns Cardinality
	 *
	 * Constraint:
	 *     (from=INT (to=INT | many?='*'))
	 */
	protected void sequence_Cardinality(ISerializationContext context, Cardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptReference returns ConceptReference
	 *
	 * Constraint:
	 *     (id=ConceptID term=TERM_STRING?)
	 */
	protected void sequence_ConceptReference(ISerializationContext context, ConceptReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DisjunctionAttributeSet returns ConjunctionAttributeSet
	 *     DisjunctionAttributeSet.DisjunctionAttributeSet_1_0_0_0 returns ConjunctionAttributeSet
	 *     ConjunctionAttributeSet returns ConjunctionAttributeSet
	 *     ConjunctionAttributeSet.ConjunctionAttributeSet_1_0_0_0 returns ConjunctionAttributeSet
	 *     PrimaryAttributeSet returns ConjunctionAttributeSet
	 *     ParenthesizedAttributeSet returns ConjunctionAttributeSet
	 *
	 * Constraint:
	 *     (left=ConjunctionAttributeSet_ConjunctionAttributeSet_1_0_0_0 op=ConjunctionOperator right=PrimaryAttributeSet)
	 */
	protected void sequence_ConjunctionAttributeSet(ISerializationContext context, ConjunctionAttributeSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionAttributeSetAccess().getConjunctionAttributeSetLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionAttributeSetAccess().getOpConjunctionOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getConjunctionAttributeSetAccess().getRightPrimaryAttributeSetParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionConstraint returns ConjunctionExpressionConstraint
	 *     ExclusionExpressionConstraint returns ConjunctionExpressionConstraint
	 *     ExclusionExpressionConstraint.ExclusionExpressionConstraint_1_0_0_0 returns ConjunctionExpressionConstraint
	 *     DisjunctionExpressionConstraint returns ConjunctionExpressionConstraint
	 *     DisjunctionExpressionConstraint.DisjunctionExpressionConstraint_1_0_0_0 returns ConjunctionExpressionConstraint
	 *     ConjunctionExpressionConstraint returns ConjunctionExpressionConstraint
	 *     ConjunctionExpressionConstraint.ConjunctionExpressionConstraint_1_0_0_0 returns ConjunctionExpressionConstraint
	 *     PrimaryExpressionConstraint.ParenthesizedExpressionConstraint_1_2 returns ConjunctionExpressionConstraint
	 *
	 * Constraint:
	 *     (left=ConjunctionExpressionConstraint_ConjunctionExpressionConstraint_1_0_0_0 op=ConjunctionOperator right=RefinedExpressionConstraint)
	 */
	protected void sequence_ConjunctionExpressionConstraint(ISerializationContext context, ConjunctionExpressionConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionExpressionConstraintAccess().getConjunctionExpressionConstraintLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionExpressionConstraintAccess().getOpConjunctionOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getConjunctionExpressionConstraintAccess().getRightRefinedExpressionConstraintParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Refinement returns ConjunctionRefinementSet
	 *     DisjunctionRefinementSet returns ConjunctionRefinementSet
	 *     DisjunctionRefinementSet.DisjunctionRefinementSet_1_0_0_0 returns ConjunctionRefinementSet
	 *     ConjunctionRefinementSet returns ConjunctionRefinementSet
	 *     ConjunctionRefinementSet.ConjunctionRefinementSet_1_0_0_0 returns ConjunctionRefinementSet
	 *     SubRefinement returns ConjunctionRefinementSet
	 *     ParenthesizedRefinement returns ConjunctionRefinementSet
	 *
	 * Constraint:
	 *     (left=ConjunctionRefinementSet_ConjunctionRefinementSet_1_0_0_0 op=ConjunctionOperator right=SubRefinement)
	 */
	protected void sequence_ConjunctionRefinementSet(ISerializationContext context, ConjunctionRefinementSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionRefinementSetAccess().getConjunctionRefinementSetLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionRefinementSetAccess().getOpConjunctionOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getConjunctionRefinementSetAccess().getRightSubRefinementParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DisjunctionAttributeSet returns DisjunctionAttributeSet
	 *     DisjunctionAttributeSet.DisjunctionAttributeSet_1_0_0_0 returns DisjunctionAttributeSet
	 *     ConjunctionAttributeSet returns DisjunctionAttributeSet
	 *     ConjunctionAttributeSet.ConjunctionAttributeSet_1_0_0_0 returns DisjunctionAttributeSet
	 *     PrimaryAttributeSet returns DisjunctionAttributeSet
	 *     ParenthesizedAttributeSet returns DisjunctionAttributeSet
	 *
	 * Constraint:
	 *     (left=DisjunctionAttributeSet_DisjunctionAttributeSet_1_0_0_0 op=DisjunctionOperator right=ConjunctionAttributeSet)
	 */
	protected void sequence_DisjunctionAttributeSet(ISerializationContext context, DisjunctionAttributeSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisjunctionAttributeSetAccess().getDisjunctionAttributeSetLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDisjunctionAttributeSetAccess().getOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getDisjunctionAttributeSetAccess().getRightConjunctionAttributeSetParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionConstraint returns DisjunctionExpressionConstraint
	 *     ExclusionExpressionConstraint returns DisjunctionExpressionConstraint
	 *     ExclusionExpressionConstraint.ExclusionExpressionConstraint_1_0_0_0 returns DisjunctionExpressionConstraint
	 *     DisjunctionExpressionConstraint returns DisjunctionExpressionConstraint
	 *     DisjunctionExpressionConstraint.DisjunctionExpressionConstraint_1_0_0_0 returns DisjunctionExpressionConstraint
	 *     PrimaryExpressionConstraint.ParenthesizedExpressionConstraint_1_2 returns DisjunctionExpressionConstraint
	 *
	 * Constraint:
	 *     (left=DisjunctionExpressionConstraint_DisjunctionExpressionConstraint_1_0_0_0 op=DisjunctionOperator right=ConjunctionExpressionConstraint)
	 */
	protected void sequence_DisjunctionExpressionConstraint(ISerializationContext context, DisjunctionExpressionConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisjunctionExpressionConstraintAccess().getDisjunctionExpressionConstraintLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDisjunctionExpressionConstraintAccess().getOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getDisjunctionExpressionConstraintAccess().getRightConjunctionExpressionConstraintParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Refinement returns DisjunctionRefinementSet
	 *     DisjunctionRefinementSet returns DisjunctionRefinementSet
	 *     DisjunctionRefinementSet.DisjunctionRefinementSet_1_0_0_0 returns DisjunctionRefinementSet
	 *     ConjunctionRefinementSet returns DisjunctionRefinementSet
	 *     ConjunctionRefinementSet.ConjunctionRefinementSet_1_0_0_0 returns DisjunctionRefinementSet
	 *     SubRefinement returns DisjunctionRefinementSet
	 *     ParenthesizedRefinement returns DisjunctionRefinementSet
	 *
	 * Constraint:
	 *     (left=DisjunctionRefinementSet_DisjunctionRefinementSet_1_0_0_0 op=DisjunctionOperator right=ConjunctionRefinementSet)
	 */
	protected void sequence_DisjunctionRefinementSet(ISerializationContext context, DisjunctionRefinementSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisjunctionRefinementSetAccess().getDisjunctionRefinementSetLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDisjunctionRefinementSetAccess().getOpDisjunctionOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getDisjunctionRefinementSetAccess().getRightConjunctionRefinementSetParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionConstraint returns ExclusionExpressionConstraint
	 *     ExclusionExpressionConstraint returns ExclusionExpressionConstraint
	 *     ExclusionExpressionConstraint.ExclusionExpressionConstraint_1_0_0_0 returns ExclusionExpressionConstraint
	 *     PrimaryExpressionConstraint.ParenthesizedExpressionConstraint_1_2 returns ExclusionExpressionConstraint
	 *
	 * Constraint:
	 *     (left=ExclusionExpressionConstraint_ExclusionExpressionConstraint_1_0_0_0 op=ExclusionOperator right=DisjunctionExpressionConstraint)
	 */
	protected void sequence_ExclusionExpressionConstraint(ISerializationContext context, ExclusionExpressionConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.COMPOUND_ELEMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusionExpressionConstraintAccess().getExclusionExpressionConstraintLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExclusionExpressionConstraintAccess().getOpExclusionOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getExclusionExpressionConstraintAccess().getRightDisjunctionExpressionConstraintParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValue returns ExpressionValue
	 *     ExpressionValue returns ExpressionValue
	 *
	 * Constraint:
	 *     (op=ExpressionComparisonOperator value=PrimaryExpressionConstraint)
	 */
	protected void sequence_ExpressionValue(ISerializationContext context, ExpressionValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.ATTRIBUTE_VALUE__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.ATTRIBUTE_VALUE__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.EXPRESSION_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.EXPRESSION_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionValueAccess().getOpExpressionComparisonOperatorEnumRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getExpressionValueAccess().getValuePrimaryExpressionConstraintParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FocusConcept returns FocusConcept
	 *
	 * Constraint:
	 *     (memberOf?='^'? (conceptRef=ConceptReference | wildcard?='*'))
	 */
	protected void sequence_FocusConcept(ISerializationContext context, FocusConcept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValue returns NumericValue
	 *     NumericValue returns NumericValue
	 *
	 * Constraint:
	 *     (op=NumericComparisonOperator value=Number)
	 */
	protected void sequence_NumericValue(ISerializationContext context, NumericValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.ATTRIBUTE_VALUE__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.ATTRIBUTE_VALUE__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.NUMERIC_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.NUMERIC_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumericValueAccess().getOpNumericComparisonOperatorEnumRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getNumericValueAccess().getValueNumberParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionConstraint returns ParenthesizedExpressionConstraint
	 *     ExclusionExpressionConstraint returns ParenthesizedExpressionConstraint
	 *     ExclusionExpressionConstraint.ExclusionExpressionConstraint_1_0_0_0 returns ParenthesizedExpressionConstraint
	 *     DisjunctionExpressionConstraint returns ParenthesizedExpressionConstraint
	 *     DisjunctionExpressionConstraint.DisjunctionExpressionConstraint_1_0_0_0 returns ParenthesizedExpressionConstraint
	 *     ConjunctionExpressionConstraint returns ParenthesizedExpressionConstraint
	 *     ConjunctionExpressionConstraint.ConjunctionExpressionConstraint_1_0_0_0 returns ParenthesizedExpressionConstraint
	 *     RefinedExpressionConstraint returns ParenthesizedExpressionConstraint
	 *     RefinedExpressionConstraint.RefinedExpressionConstraint_1_0 returns ParenthesizedExpressionConstraint
	 *     PrimaryExpressionConstraint returns ParenthesizedExpressionConstraint
	 *     PrimaryExpressionConstraint.ParenthesizedExpressionConstraint_1_2 returns ParenthesizedExpressionConstraint
	 *
	 * Constraint:
	 *     current=PrimaryExpressionConstraint_ParenthesizedExpressionConstraint_1_2
	 */
	protected void sequence_PrimaryExpressionConstraint(ISerializationContext context, ParenthesizedExpressionConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.PARENTHESIZED_EXPRESSION_CONSTRAINT__CURRENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.PARENTHESIZED_EXPRESSION_CONSTRAINT__CURRENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionConstraintAccess().getParenthesizedExpressionConstraintCurrentAction_1_2(), semanticObject.getCurrent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionConstraint returns RefinedExpressionConstraint
	 *     ExclusionExpressionConstraint returns RefinedExpressionConstraint
	 *     ExclusionExpressionConstraint.ExclusionExpressionConstraint_1_0_0_0 returns RefinedExpressionConstraint
	 *     DisjunctionExpressionConstraint returns RefinedExpressionConstraint
	 *     DisjunctionExpressionConstraint.DisjunctionExpressionConstraint_1_0_0_0 returns RefinedExpressionConstraint
	 *     ConjunctionExpressionConstraint returns RefinedExpressionConstraint
	 *     ConjunctionExpressionConstraint.ConjunctionExpressionConstraint_1_0_0_0 returns RefinedExpressionConstraint
	 *     RefinedExpressionConstraint returns RefinedExpressionConstraint
	 *     PrimaryExpressionConstraint.ParenthesizedExpressionConstraint_1_2 returns RefinedExpressionConstraint
	 *
	 * Constraint:
	 *     (target=RefinedExpressionConstraint_RefinedExpressionConstraint_1_0 refinement=Refinement)
	 */
	protected void sequence_RefinedExpressionConstraint(ISerializationContext context, RefinedExpressionConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.REFINED_EXPRESSION_CONSTRAINT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.REFINED_EXPRESSION_CONSTRAINT__TARGET));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.REFINED_EXPRESSION_CONSTRAINT__REFINEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.REFINED_EXPRESSION_CONSTRAINT__REFINEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefinedExpressionConstraintAccess().getRefinedExpressionConstraintTargetAction_1_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getRefinedExpressionConstraintAccess().getRefinementRefinementParserRuleCall_1_2_0(), semanticObject.getRefinement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Script returns Script
	 *
	 * Constraint:
	 *     constraint=ExpressionConstraint
	 */
	protected void sequence_Script(ISerializationContext context, Script semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.SCRIPT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.SCRIPT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScriptAccess().getConstraintExpressionConstraintParserRuleCall_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionConstraint returns SimpleExpressionConstraint
	 *     ExclusionExpressionConstraint returns SimpleExpressionConstraint
	 *     ExclusionExpressionConstraint.ExclusionExpressionConstraint_1_0_0_0 returns SimpleExpressionConstraint
	 *     DisjunctionExpressionConstraint returns SimpleExpressionConstraint
	 *     DisjunctionExpressionConstraint.DisjunctionExpressionConstraint_1_0_0_0 returns SimpleExpressionConstraint
	 *     ConjunctionExpressionConstraint returns SimpleExpressionConstraint
	 *     ConjunctionExpressionConstraint.ConjunctionExpressionConstraint_1_0_0_0 returns SimpleExpressionConstraint
	 *     RefinedExpressionConstraint returns SimpleExpressionConstraint
	 *     RefinedExpressionConstraint.RefinedExpressionConstraint_1_0 returns SimpleExpressionConstraint
	 *     PrimaryExpressionConstraint returns SimpleExpressionConstraint
	 *     PrimaryExpressionConstraint.ParenthesizedExpressionConstraint_1_2 returns SimpleExpressionConstraint
	 *     SimpleExpressionConstraint returns SimpleExpressionConstraint
	 *
	 * Constraint:
	 *     (op=ConstraintOperator? concept=FocusConcept)
	 */
	protected void sequence_SimpleExpressionConstraint(ISerializationContext context, SimpleExpressionConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValue returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     (op=StringComparisonOperator value=STRING)
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.ATTRIBUTE_VALUE__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.ATTRIBUTE_VALUE__OP));
			if (transientValues.isValueTransient(semanticObject, EclPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EclPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getOpStringComparisonOperatorEnumRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
